#---------------------------------
# AWS ECR Docker jobs
#
# Input variables:
# AWS_ACCOUNT_ID - acoount ID in AWS
# AWS_REGION - AWS region
# AWS_ECR_NAMESPACE - optional, namespace of the repository in AWS, e.g. my-namespace
# AWS_PROFILE - optional, profile to use for authentication
# SKIP_ARM64 - optional, operations for arm64 architecture will be silently skipped
#
# Derived variables:
# AWS_ECR_REGISTRY - name of the registry, e.g. 1234.dkr.ecr.us-east1.amazonaws.com
# AWS_ECR_REGISTRY_IMAGE_BASE - base name of the target image e.g. 1234.dkr.ecr.us-east1.amazonaws.com/my-namespace/my-project
# AWS_ECR_REGISTRY_IMAGE_VER - name of the target image, including version e.g. 1234.dkr.ecr.us-east1.amazonaws.com/my-namespace/my-project:1.2.3
#
#----------
# Base jobs

.on-amd64: &on-amd64
  tags:
    - docker-amd64
  variables:
    cpuArch: "amd64"

.on-arm64: &on-arm64
  tags:
    - docker-arm64
  variables:
    cpuArch: "arm64"

# Checks SKIP_ARM64 variable and changes armImageName script variable to empty instead of $AWS_ECR_REGISTRY_IMAGE_VER-arm64
# This is useful to exclude arm64 from manifests in scripts etc.
.arm64-image-name-check: &arm64-image-name-check
  arm64ImageName=$([ "${SKIP_ARM64:-}" = "true" ] || [ "${SKIP_ARM64:-}" = "yes" ] && echo "" || echo "$AWS_ECR_REGISTRY_IMAGE_VER-arm64")

# Part of a script to anchor
# Checks if script executes with variable $cpuArch set to "arm64" and SKIP_ARM64 is set to true/yes.
# If that's the case then executing script exits with status 0
.script-exit0-if-arm64-skip-set: &script-exit0-if-arm64-skip-set
  configuredToSkipArm64=$([ "${SKIP_ARM64:-}" = "true" ] || [ "${SKIP_ARM64:-}" = "yes" ] && echo "true" || echo "false") &&
  if [ "$cpuArch" = "arm64" ] && [ "$configuredToSkipArm64" = "true" ]; then echo "Configured to skip arm64 architecture. Exiting with code 0"; exit 0; fi
  
.docker-ecr-auth-job:
  image: $REGISTRY_HOST/docker-and-aws:0.0.1-$cpuArch
  variables:
    # does not use source code
    GIT_STRATEGY: none
  dependencies: []
  before_script:
    # values defined here instead of using Gitlab variables because this version does not support expansion
    # instead we use shell's capabilities
    # we want to avoid duplication
    - AWS_ECR_REGISTRY=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com
    - awsNamespacePart="${AWS_ECR_NAMESPACE:+$AWS_ECR_NAMESPACE/}"
    - AWS_ECR_REGISTRY_IMAGE_BASE=${AWS_ECR_REGISTRY}/${awsNamespacePart}${CI_PROJECT_NAME}
    - AWS_ECR_REGISTRY_IMAGE_VER=${AWS_ECR_REGISTRY_IMAGE_BASE}:${CI_COMMIT_TAG}
    # aws authentication using profile or provided access key details
    - aws ecr get-login-password ${AWS_PROFILE:+--profile ${AWS_PROFILE}} ${AWS_REGION:+--region ${AWS_REGION}} | docker login --username AWS --password-stdin $AWS_ECR_REGISTRY
  only:
    - tags

#----------
# Push images

push-to-ecr-amd64:
  <<: *on-amd64
  extends: .push-to-ecr

push-to-ecr-arm64:
  <<: *on-arm64
  extends: .push-to-ecr

# Base job pushing architecture-specific image to ECR
.push-to-ecr:
  stage: docker-push-images
  extends: .docker-ecr-auth-job
  script:
    - *script-exit0-if-arm64-skip-set
    - docker tag $REGISTRY_IMAGE_VER-$cpuArch $AWS_ECR_REGISTRY_IMAGE_VER-$cpuArch
    - docker push $AWS_ECR_REGISTRY_IMAGE_VER-$cpuArch
  only:
    - tags
#----------
# Create manifest

# To be able to resolve $cpuArch in the image name force the job to run on a specific architecture
# Also this wrapper job allows us to avoid problems with late resolution of $cpuArch 
create-manifest-ecr:
  <<: *on-amd64
  extends: .create-manifest-ecr
  only:
    - tags

# Create docker manifest list for tag :version in AWS ECR
.create-manifest-ecr:
  stage: docker-publish-manifests
  extends: .docker-ecr-auth-job
  script:
    - *arm64-image-name-check
    - docker manifest create $AWS_ECR_REGISTRY_IMAGE_VER $AWS_ECR_REGISTRY_IMAGE_VER-amd64 $arm64ImageName
    - docker manifest push --purge $AWS_ECR_REGISTRY_IMAGE_VER

#----------
# Create tag :latest

# To be able to resolve $cpuArch in the image name force the job to run on a specific architecture
# Also this wrapper job allows us to avoid problems with late resolution of $cpuArch 
create-latest-tag-ecr:
  <<: *on-amd64
  extends: .create-latest-tag-ecr
  only:
    # Checking the format of the Git tag is the only thing that works
    # We cannot check for example if the tag is on the master branch
    - /^\d+\.\d+\.\d+$/

# Create docker manifest list for tag :latest
.create-latest-tag-ecr:
  stage: docker-publish-manifests
  extends: .docker-ecr-auth-job
  script:
    - *arm64-image-name-check
    - docker manifest create $AWS_ECR_REGISTRY_IMAGE_BASE:latest $AWS_ECR_REGISTRY_IMAGE_VER-amd64 $arm64ImageName
    - docker manifest push --purge $AWS_ECR_REGISTRY_IMAGE_BASE:latest

#----------
# Cleanup

# Remove docker image for amd64
cleanup-ecr-amd64:
  <<: *on-amd64
  extends: .remove-image-ecr-base

## Remove docker image for arm64
cleanup-ecr-arm64:
  <<: *on-arm64
  extends: .remove-image-ecr-base

# Base task for removing built Docker image
.remove-image-ecr-base:
  extends: .docker-ecr-auth-job
  stage: docker-cleanup-images
  script:
    - docker image rm -f $AWS_ECR_REGISTRY_IMAGE_VER-$cpuArch
    # this is likely redundant call since previous call untags everything
    - docker image rm -f $AWS_ECR_REGISTRY_IMAGE_VER
#----------
